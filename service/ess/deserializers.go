// Code generated by smithy-go-codegen DO NOT EDIT.


package ess

import (
	awsmiddleware "github.com/aws/aws-sdk-go-v2/aws/middleware"
	awsxml "github.com/aws/aws-sdk-go-v2/aws/protocol/xml"
	"bytes"
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"github.com/aws/smithy-go/middleware"
	"github.com/aws/smithy-go/ptr"
	smithy "github.com/aws/smithy-go"
	smithyhttp "github.com/aws/smithy-go/transport/http"
	smithyio "github.com/aws/smithy-go/io"
	smithytime "github.com/aws/smithy-go/time"
	smithyxml "github.com/aws/smithy-go/encoding/xml"
	"strconv"
	"strings"
	"github.com/nifcloud/nifcloud-sdk-go/service/ess/types"
	"encoding/xml"
)

type awsAwsquery_deserializeOpDeleteIdentity struct {
}

func (*awsAwsquery_deserializeOpDeleteIdentity) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpDeleteIdentity) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorDeleteIdentity(response, &metadata)
	}
	output := &DeleteIdentityOutput{}
	out.Result = output
	
	if _, err = io.Copy(ioutil.Discard, response.Body); err != nil {
		return out, metadata, &smithy.DeserializationError{
			Err: fmt.Errorf("failed to discard response body, %w", err),
		}
	}
	
	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorDeleteIdentity(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	errorComponents, err := awsxml.GetErrorResponseComponents(errorBody, false)
	if err != nil { return err }
	if reqID := errorComponents.RequestID; len(reqID)!=0 {
		awsmiddleware.SetRequestIDMetadata(metadata, reqID)
	}
	if len(errorComponents.Code) != 0 { errorCode = errorComponents.Code}
	if len(errorComponents.Message) != 0 { errorMessage = errorComponents.Message}
	errorBody.Seek(0, io.SeekStart)
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsquery_deserializeOpGetDeliveryLog struct {
}

func (*awsAwsquery_deserializeOpGetDeliveryLog) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpGetDeliveryLog) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorGetDeliveryLog(response, &metadata)
	}
	output := &GetDeliveryLogOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF { return out, metadata, nil}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError {
			Err : fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}
	
	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	t, err = decoder.GetElement("GetDeliveryLogResult")
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	decoder = smithyxml.WrapNodeDecoder(decoder.Decoder, t)
	err = awsAwsquery_deserializeOpDocumentGetDeliveryLogOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorGetDeliveryLog(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	errorComponents, err := awsxml.GetErrorResponseComponents(errorBody, false)
	if err != nil { return err }
	if reqID := errorComponents.RequestID; len(reqID)!=0 {
		awsmiddleware.SetRequestIDMetadata(metadata, reqID)
	}
	if len(errorComponents.Code) != 0 { errorCode = errorComponents.Code}
	if len(errorComponents.Message) != 0 { errorMessage = errorComponents.Message}
	errorBody.Seek(0, io.SeekStart)
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsquery_deserializeOpGetIdentityDkimAttributes struct {
}

func (*awsAwsquery_deserializeOpGetIdentityDkimAttributes) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpGetIdentityDkimAttributes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorGetIdentityDkimAttributes(response, &metadata)
	}
	output := &GetIdentityDkimAttributesOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF { return out, metadata, nil}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError {
			Err : fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}
	
	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	t, err = decoder.GetElement("GetIdentityDkimAttributesResult")
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	decoder = smithyxml.WrapNodeDecoder(decoder.Decoder, t)
	err = awsAwsquery_deserializeOpDocumentGetIdentityDkimAttributesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorGetIdentityDkimAttributes(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	errorComponents, err := awsxml.GetErrorResponseComponents(errorBody, false)
	if err != nil { return err }
	if reqID := errorComponents.RequestID; len(reqID)!=0 {
		awsmiddleware.SetRequestIDMetadata(metadata, reqID)
	}
	if len(errorComponents.Code) != 0 { errorCode = errorComponents.Code}
	if len(errorComponents.Message) != 0 { errorMessage = errorComponents.Message}
	errorBody.Seek(0, io.SeekStart)
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsquery_deserializeOpGetIdentityVerificationAttributes struct {
}

func (*awsAwsquery_deserializeOpGetIdentityVerificationAttributes) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpGetIdentityVerificationAttributes) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorGetIdentityVerificationAttributes(response, &metadata)
	}
	output := &GetIdentityVerificationAttributesOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF { return out, metadata, nil}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError {
			Err : fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}
	
	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	t, err = decoder.GetElement("GetIdentityVerificationAttributesResult")
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	decoder = smithyxml.WrapNodeDecoder(decoder.Decoder, t)
	err = awsAwsquery_deserializeOpDocumentGetIdentityVerificationAttributesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorGetIdentityVerificationAttributes(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	errorComponents, err := awsxml.GetErrorResponseComponents(errorBody, false)
	if err != nil { return err }
	if reqID := errorComponents.RequestID; len(reqID)!=0 {
		awsmiddleware.SetRequestIDMetadata(metadata, reqID)
	}
	if len(errorComponents.Code) != 0 { errorCode = errorComponents.Code}
	if len(errorComponents.Message) != 0 { errorMessage = errorComponents.Message}
	errorBody.Seek(0, io.SeekStart)
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsquery_deserializeOpGetSendQuota struct {
}

func (*awsAwsquery_deserializeOpGetSendQuota) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpGetSendQuota) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorGetSendQuota(response, &metadata)
	}
	output := &GetSendQuotaOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF { return out, metadata, nil}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError {
			Err : fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}
	
	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	t, err = decoder.GetElement("GetSendQuotaResult")
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	decoder = smithyxml.WrapNodeDecoder(decoder.Decoder, t)
	err = awsAwsquery_deserializeOpDocumentGetSendQuotaOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorGetSendQuota(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	errorComponents, err := awsxml.GetErrorResponseComponents(errorBody, false)
	if err != nil { return err }
	if reqID := errorComponents.RequestID; len(reqID)!=0 {
		awsmiddleware.SetRequestIDMetadata(metadata, reqID)
	}
	if len(errorComponents.Code) != 0 { errorCode = errorComponents.Code}
	if len(errorComponents.Message) != 0 { errorMessage = errorComponents.Message}
	errorBody.Seek(0, io.SeekStart)
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsquery_deserializeOpGetSendStatistics struct {
}

func (*awsAwsquery_deserializeOpGetSendStatistics) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpGetSendStatistics) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorGetSendStatistics(response, &metadata)
	}
	output := &GetSendStatisticsOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF { return out, metadata, nil}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError {
			Err : fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}
	
	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	t, err = decoder.GetElement("GetSendStatisticsResult")
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	decoder = smithyxml.WrapNodeDecoder(decoder.Decoder, t)
	err = awsAwsquery_deserializeOpDocumentGetSendStatisticsOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorGetSendStatistics(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	errorComponents, err := awsxml.GetErrorResponseComponents(errorBody, false)
	if err != nil { return err }
	if reqID := errorComponents.RequestID; len(reqID)!=0 {
		awsmiddleware.SetRequestIDMetadata(metadata, reqID)
	}
	if len(errorComponents.Code) != 0 { errorCode = errorComponents.Code}
	if len(errorComponents.Message) != 0 { errorMessage = errorComponents.Message}
	errorBody.Seek(0, io.SeekStart)
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsquery_deserializeOpListIdentities struct {
}

func (*awsAwsquery_deserializeOpListIdentities) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpListIdentities) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorListIdentities(response, &metadata)
	}
	output := &ListIdentitiesOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF { return out, metadata, nil}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError {
			Err : fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}
	
	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	t, err = decoder.GetElement("ListIdentitiesResult")
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	decoder = smithyxml.WrapNodeDecoder(decoder.Decoder, t)
	err = awsAwsquery_deserializeOpDocumentListIdentitiesOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorListIdentities(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	errorComponents, err := awsxml.GetErrorResponseComponents(errorBody, false)
	if err != nil { return err }
	if reqID := errorComponents.RequestID; len(reqID)!=0 {
		awsmiddleware.SetRequestIDMetadata(metadata, reqID)
	}
	if len(errorComponents.Code) != 0 { errorCode = errorComponents.Code}
	if len(errorComponents.Message) != 0 { errorMessage = errorComponents.Message}
	errorBody.Seek(0, io.SeekStart)
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsquery_deserializeOpSendEmail struct {
}

func (*awsAwsquery_deserializeOpSendEmail) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpSendEmail) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorSendEmail(response, &metadata)
	}
	output := &SendEmailOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF { return out, metadata, nil}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError {
			Err : fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}
	
	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	t, err = decoder.GetElement("SendEmailResult")
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	decoder = smithyxml.WrapNodeDecoder(decoder.Decoder, t)
	err = awsAwsquery_deserializeOpDocumentSendEmailOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorSendEmail(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	errorComponents, err := awsxml.GetErrorResponseComponents(errorBody, false)
	if err != nil { return err }
	if reqID := errorComponents.RequestID; len(reqID)!=0 {
		awsmiddleware.SetRequestIDMetadata(metadata, reqID)
	}
	if len(errorComponents.Code) != 0 { errorCode = errorComponents.Code}
	if len(errorComponents.Message) != 0 { errorMessage = errorComponents.Message}
	errorBody.Seek(0, io.SeekStart)
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsquery_deserializeOpSendRawEmail struct {
}

func (*awsAwsquery_deserializeOpSendRawEmail) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpSendRawEmail) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorSendRawEmail(response, &metadata)
	}
	output := &SendRawEmailOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF { return out, metadata, nil}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError {
			Err : fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}
	
	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	t, err = decoder.GetElement("SendRawEmailResult")
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	decoder = smithyxml.WrapNodeDecoder(decoder.Decoder, t)
	err = awsAwsquery_deserializeOpDocumentSendRawEmailOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorSendRawEmail(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	errorComponents, err := awsxml.GetErrorResponseComponents(errorBody, false)
	if err != nil { return err }
	if reqID := errorComponents.RequestID; len(reqID)!=0 {
		awsmiddleware.SetRequestIDMetadata(metadata, reqID)
	}
	if len(errorComponents.Code) != 0 { errorCode = errorComponents.Code}
	if len(errorComponents.Message) != 0 { errorMessage = errorComponents.Message}
	errorBody.Seek(0, io.SeekStart)
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsquery_deserializeOpSetIdentityDkimEnabled struct {
}

func (*awsAwsquery_deserializeOpSetIdentityDkimEnabled) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpSetIdentityDkimEnabled) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorSetIdentityDkimEnabled(response, &metadata)
	}
	output := &SetIdentityDkimEnabledOutput{}
	out.Result = output
	
	if _, err = io.Copy(ioutil.Discard, response.Body); err != nil {
		return out, metadata, &smithy.DeserializationError{
			Err: fmt.Errorf("failed to discard response body, %w", err),
		}
	}
	
	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorSetIdentityDkimEnabled(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	errorComponents, err := awsxml.GetErrorResponseComponents(errorBody, false)
	if err != nil { return err }
	if reqID := errorComponents.RequestID; len(reqID)!=0 {
		awsmiddleware.SetRequestIDMetadata(metadata, reqID)
	}
	if len(errorComponents.Code) != 0 { errorCode = errorComponents.Code}
	if len(errorComponents.Message) != 0 { errorMessage = errorComponents.Message}
	errorBody.Seek(0, io.SeekStart)
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsquery_deserializeOpVerifyDomainDkim struct {
}

func (*awsAwsquery_deserializeOpVerifyDomainDkim) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpVerifyDomainDkim) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorVerifyDomainDkim(response, &metadata)
	}
	output := &VerifyDomainDkimOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF { return out, metadata, nil}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError {
			Err : fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}
	
	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	t, err = decoder.GetElement("VerifyDomainDkimResult")
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	decoder = smithyxml.WrapNodeDecoder(decoder.Decoder, t)
	err = awsAwsquery_deserializeOpDocumentVerifyDomainDkimOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorVerifyDomainDkim(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	errorComponents, err := awsxml.GetErrorResponseComponents(errorBody, false)
	if err != nil { return err }
	if reqID := errorComponents.RequestID; len(reqID)!=0 {
		awsmiddleware.SetRequestIDMetadata(metadata, reqID)
	}
	if len(errorComponents.Code) != 0 { errorCode = errorComponents.Code}
	if len(errorComponents.Message) != 0 { errorMessage = errorComponents.Message}
	errorBody.Seek(0, io.SeekStart)
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsquery_deserializeOpVerifyDomainIdentity struct {
}

func (*awsAwsquery_deserializeOpVerifyDomainIdentity) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpVerifyDomainIdentity) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorVerifyDomainIdentity(response, &metadata)
	}
	output := &VerifyDomainIdentityOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF { return out, metadata, nil}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError {
			Err : fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}
	
	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	t, err = decoder.GetElement("VerifyDomainIdentityResult")
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	decoder = smithyxml.WrapNodeDecoder(decoder.Decoder, t)
	err = awsAwsquery_deserializeOpDocumentVerifyDomainIdentityOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorVerifyDomainIdentity(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	errorComponents, err := awsxml.GetErrorResponseComponents(errorBody, false)
	if err != nil { return err }
	if reqID := errorComponents.RequestID; len(reqID)!=0 {
		awsmiddleware.SetRequestIDMetadata(metadata, reqID)
	}
	if len(errorComponents.Code) != 0 { errorCode = errorComponents.Code}
	if len(errorComponents.Message) != 0 { errorMessage = errorComponents.Message}
	errorBody.Seek(0, io.SeekStart)
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

type awsAwsquery_deserializeOpVerifyEmailIdentity struct {
}

func (*awsAwsquery_deserializeOpVerifyEmailIdentity) ID() string {
	return "OperationDeserializer"
}

func (m *awsAwsquery_deserializeOpVerifyEmailIdentity) HandleDeserialize(ctx context.Context, in middleware.DeserializeInput, next middleware.DeserializeHandler) (
	out middleware.DeserializeOutput, metadata middleware.Metadata, err error,
) {
	out, metadata, err = next.HandleDeserialize(ctx, in)
	if err != nil { return out, metadata, err }
	
	response, ok := out.RawResponse.(*smithyhttp.Response)
	if !ok {
		return out, metadata, &smithy.DeserializationError{Err: fmt.Errorf("unknown transport type %T", out.RawResponse)}
	}
	
	if response.StatusCode < 200 || response.StatusCode >= 300 {
		return out, metadata, awsAwsquery_deserializeOpErrorVerifyEmailIdentity(response, &metadata)
	}
	output := &VerifyEmailIdentityOutput{}
	out.Result = output
	
	var buff [1024]byte
	ringBuffer := smithyio.NewRingBuffer(buff[:])
	body := io.TeeReader(response.Body, ringBuffer)
	rootDecoder := xml.NewDecoder(body)
	t, err := smithyxml.FetchRootElement(rootDecoder)
	if err == io.EOF { return out, metadata, nil}
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		return out, metadata, &smithy.DeserializationError {
			Err : fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
	}
	
	decoder := smithyxml.WrapNodeDecoder(rootDecoder, t)
	t, err = decoder.GetElement("VerifyEmailIdentityResult")
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	decoder = smithyxml.WrapNodeDecoder(decoder.Decoder, t)
	err = awsAwsquery_deserializeOpDocumentVerifyEmailIdentityOutput(&output, decoder)
	if err != nil {
		var snapshot bytes.Buffer
		io.Copy(&snapshot, ringBuffer)
		err = &smithy.DeserializationError {
			Err: fmt.Errorf("failed to decode response body, %w", err),
			Snapshot: snapshot.Bytes(),
		}
		return out, metadata, err
	}
	
	return out, metadata, err
}

func awsAwsquery_deserializeOpErrorVerifyEmailIdentity(response *smithyhttp.Response, metadata *middleware.Metadata) error {
	var errorBuffer bytes.Buffer
	if _, err := io.Copy(&errorBuffer, response.Body); err != nil {
		return &smithy.DeserializationError{Err: fmt.Errorf("failed to copy error response body, %w", err)}
	}
	errorBody := bytes.NewReader(errorBuffer.Bytes())
	
	errorCode := "UnknownError"
	errorMessage := errorCode
	
	errorComponents, err := awsxml.GetErrorResponseComponents(errorBody, false)
	if err != nil { return err }
	if reqID := errorComponents.RequestID; len(reqID)!=0 {
		awsmiddleware.SetRequestIDMetadata(metadata, reqID)
	}
	if len(errorComponents.Code) != 0 { errorCode = errorComponents.Code}
	if len(errorComponents.Message) != 0 { errorMessage = errorComponents.Message}
	errorBody.Seek(0, io.SeekStart)
	switch {
		default:
			genericError := &smithy.GenericAPIError{
				Code: errorCode,
				Message: errorMessage,
			}
			return genericError
		
	}
}

func awsAwsquery_deserializeDocumentDkimAttributes(v **types.DkimAttributes, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.DkimAttributes
	if *v == nil {
		sv = &types.DkimAttributes{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("key", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					sv.Key = ptr.String(xtv)
				}
			
			case strings.EqualFold("value", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentValueOfGetIdentityDkimAttributes(&sv.Value, nodeDecoder); err != nil {
					return err
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentListOfDkimAttributes(v *[]types.DkimAttributes, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []types.DkimAttributes
	if *v == nil {
		sv = make([]types.DkimAttributes, 0)
		} else {
			sv = *v
		}
	
	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		switch {
			case strings.EqualFold("entry", t.Name.Local):
				var col types.DkimAttributes
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				destAddr := &col
				if err := awsAwsquery_deserializeDocumentDkimAttributes(&destAddr, nodeDecoder); err != nil {
					return err
				}
				col = *destAddr
				sv = append(sv, col)
			
			default:
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentListOfDkimAttributesUnwrapped(v *[]types.DkimAttributes, decoder smithyxml.NodeDecoder) error {
	var sv []types.DkimAttributes
	if *v == nil {
		sv = make([]types.DkimAttributes, 0)
		} else {
			sv = *v
		}
	
	 switch { default:
		var mv types.DkimAttributes
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		destAddr := &mv
		if err := awsAwsquery_deserializeDocumentDkimAttributes(&destAddr, nodeDecoder); err != nil {
			return err
		}
		mv = *destAddr
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentListOfDkimTokens(v *[]string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []string
	if *v == nil {
		sv = make([]string, 0)
		} else {
			sv = *v
		}
	
	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		switch {
			case strings.EqualFold("member", t.Name.Local):
				var col string
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					col = xtv
				}
				sv = append(sv, col)
			
			default:
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentListOfDkimTokensUnwrapped(v *[]string, decoder smithyxml.NodeDecoder) error {
	var sv []string
	if *v == nil {
		sv = make([]string, 0)
		} else {
			sv = *v
		}
	
	 switch { default:
		var mv string
		t := decoder.StartEl
		_ = t
		val, err := decoder.Value()
		if err != nil { return err }
		if val == nil { break }
		{
			xtv := string(val)
			mv = xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentListOfIdentities(v *[]string, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []string
	if *v == nil {
		sv = make([]string, 0)
		} else {
			sv = *v
		}
	
	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		memberDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		decoder = memberDecoder
		switch {
			case strings.EqualFold("member", t.Name.Local):
				var col string
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					col = xtv
				}
				sv = append(sv, col)
			
			default:
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentListOfIdentitiesUnwrapped(v *[]string, decoder smithyxml.NodeDecoder) error {
	var sv []string
	if *v == nil {
		sv = make([]string, 0)
		} else {
			sv = *v
		}
	
	 switch { default:
		var mv string
		t := decoder.StartEl
		_ = t
		val, err := decoder.Value()
		if err != nil { return err }
		if val == nil { break }
		{
			xtv := string(val)
			mv = xtv
		}
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentListOfSendDataPoints(v *[]types.SendDataPoints, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []types.SendDataPoints
	if *v == nil {
		sv = make([]types.SendDataPoints, 0)
		} else {
			sv = *v
		}
	
	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		switch {
			case strings.EqualFold("member", t.Name.Local):
				var col types.SendDataPoints
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				destAddr := &col
				if err := awsAwsquery_deserializeDocumentSendDataPoints(&destAddr, nodeDecoder); err != nil {
					return err
				}
				col = *destAddr
				sv = append(sv, col)
			
			default:
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentListOfSendDataPointsUnwrapped(v *[]types.SendDataPoints, decoder smithyxml.NodeDecoder) error {
	var sv []types.SendDataPoints
	if *v == nil {
		sv = make([]types.SendDataPoints, 0)
		} else {
			sv = *v
		}
	
	 switch { default:
		var mv types.SendDataPoints
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		destAddr := &mv
		if err := awsAwsquery_deserializeDocumentSendDataPoints(&destAddr, nodeDecoder); err != nil {
			return err
		}
		mv = *destAddr
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentListOfVerificationAttributes(v *[]types.VerificationAttributes, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv []types.VerificationAttributes
	if *v == nil {
		sv = make([]types.VerificationAttributes, 0)
		} else {
			sv = *v
		}
	
	originalDecoder := decoder
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		switch {
			case strings.EqualFold("entry", t.Name.Local):
				var col types.VerificationAttributes
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				destAddr := &col
				if err := awsAwsquery_deserializeDocumentVerificationAttributes(&destAddr, nodeDecoder); err != nil {
					return err
				}
				col = *destAddr
				sv = append(sv, col)
			
			default:
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentListOfVerificationAttributesUnwrapped(v *[]types.VerificationAttributes, decoder smithyxml.NodeDecoder) error {
	var sv []types.VerificationAttributes
	if *v == nil {
		sv = make([]types.VerificationAttributes, 0)
		} else {
			sv = *v
		}
	
	 switch { default:
		var mv types.VerificationAttributes
		t := decoder.StartEl
		_ = t
		nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
		destAddr := &mv
		if err := awsAwsquery_deserializeDocumentVerificationAttributes(&destAddr, nodeDecoder); err != nil {
			return err
		}
		mv = *destAddr
		sv = append(sv, mv)
	}
	*v = sv
	return nil
}
func awsAwsquery_deserializeDocumentResponseMetadata(v **types.ResponseMetadata, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ResponseMetadata
	if *v == nil {
		sv = &types.ResponseMetadata{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("RequestId", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					sv.RequestId = ptr.String(xtv)
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentSendDataPoints(v **types.SendDataPoints, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.SendDataPoints
	if *v == nil {
		sv = &types.SendDataPoints{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("Bounces", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					i64, err := strconv.ParseInt(xtv, 10, 64)
					if err != nil { return err }
					sv.Bounces = ptr.Int32(int32(i64))
				}
			
			case strings.EqualFold("Complaints", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					i64, err := strconv.ParseInt(xtv, 10, 64)
					if err != nil { return err }
					sv.Complaints = ptr.Int32(int32(i64))
				}
			
			case strings.EqualFold("DeliveryAttempts", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					i64, err := strconv.ParseInt(xtv, 10, 64)
					if err != nil { return err }
					sv.DeliveryAttempts = ptr.Int32(int32(i64))
				}
			
			case strings.EqualFold("Rejects", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					i64, err := strconv.ParseInt(xtv, 10, 64)
					if err != nil { return err }
					sv.Rejects = ptr.Int32(int32(i64))
				}
			
			case strings.EqualFold("Timestamp", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					t, err := smithytime.ParseDateTime(xtv)
					if err != nil { return err }
					sv.Timestamp = ptr.Time(t)
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentValue(v **types.Value, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.Value
	if *v == nil {
		sv = &types.Value{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("VerificationStatus", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					sv.VerificationStatus = ptr.String(xtv)
				}
			
			case strings.EqualFold("VerificationToken", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					sv.VerificationToken = ptr.String(xtv)
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentValueOfGetIdentityDkimAttributes(v **types.ValueOfGetIdentityDkimAttributes, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.ValueOfGetIdentityDkimAttributes
	if *v == nil {
		sv = &types.ValueOfGetIdentityDkimAttributes{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("DkimEnabled", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv, err := strconv.ParseBool(string(val))
					if err != nil {
						return fmt.Errorf("expected Boolean to be of type *bool, got %T instead", val)
					}
					sv.DkimEnabled = ptr.Bool(xtv)
				}
			
			case strings.EqualFold("DkimTokens", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentListOfDkimTokens(&sv.DkimTokens, nodeDecoder); err != nil {
					return err
				}
			
			case strings.EqualFold("DkimVerificationStatus", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					sv.DkimVerificationStatus = ptr.String(xtv)
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeDocumentVerificationAttributes(v **types.VerificationAttributes, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *types.VerificationAttributes
	if *v == nil {
		sv = &types.VerificationAttributes{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("key", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					sv.Key = ptr.String(xtv)
				}
			
			case strings.EqualFold("value", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentValue(&sv.Value, nodeDecoder); err != nil {
					return err
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentGetDeliveryLogOutput(v **GetDeliveryLogOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetDeliveryLogOutput
	if *v == nil {
		sv = &GetDeliveryLogOutput{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("Log", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					sv.Log = ptr.String(xtv)
				}
			
			case strings.EqualFold("LogCount", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					sv.LogCount = ptr.String(xtv)
				}
			
			case strings.EqualFold("NextToken", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					sv.NextToken = ptr.String(xtv)
				}
			
			case strings.EqualFold("ResponseMetadata", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentResponseMetadata(&sv.ResponseMetadata, nodeDecoder); err != nil {
					return err
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentGetIdentityDkimAttributesOutput(v **GetIdentityDkimAttributesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetIdentityDkimAttributesOutput
	if *v == nil {
		sv = &GetIdentityDkimAttributesOutput{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("DkimAttributes", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentListOfDkimAttributes(&sv.DkimAttributes, nodeDecoder); err != nil {
					return err
				}
			
			case strings.EqualFold("ResponseMetadata", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentResponseMetadata(&sv.ResponseMetadata, nodeDecoder); err != nil {
					return err
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentGetIdentityVerificationAttributesOutput(v **GetIdentityVerificationAttributesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetIdentityVerificationAttributesOutput
	if *v == nil {
		sv = &GetIdentityVerificationAttributesOutput{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("ResponseMetadata", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentResponseMetadata(&sv.ResponseMetadata, nodeDecoder); err != nil {
					return err
				}
			
			case strings.EqualFold("VerificationAttributes", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentListOfVerificationAttributes(&sv.VerificationAttributes, nodeDecoder); err != nil {
					return err
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentGetSendQuotaOutput(v **GetSendQuotaOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetSendQuotaOutput
	if *v == nil {
		sv = &GetSendQuotaOutput{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("Max24HourSend", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					f64, err := strconv.ParseFloat(xtv, 64)
					if err != nil { return err }
					sv.Max24HourSend = ptr.Float64(f64)
				}
			
			case strings.EqualFold("MaxSendRate", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					f64, err := strconv.ParseFloat(xtv, 64)
					if err != nil { return err }
					sv.MaxSendRate = ptr.Float64(f64)
				}
			
			case strings.EqualFold("ResponseMetadata", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentResponseMetadata(&sv.ResponseMetadata, nodeDecoder); err != nil {
					return err
				}
			
			case strings.EqualFold("SentLast24Hours", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					f64, err := strconv.ParseFloat(xtv, 64)
					if err != nil { return err }
					sv.SentLast24Hours = ptr.Float64(f64)
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentGetSendStatisticsOutput(v **GetSendStatisticsOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *GetSendStatisticsOutput
	if *v == nil {
		sv = &GetSendStatisticsOutput{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("ResponseMetadata", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentResponseMetadata(&sv.ResponseMetadata, nodeDecoder); err != nil {
					return err
				}
			
			case strings.EqualFold("SendDataPoints", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentListOfSendDataPoints(&sv.SendDataPoints, nodeDecoder); err != nil {
					return err
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentListIdentitiesOutput(v **ListIdentitiesOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *ListIdentitiesOutput
	if *v == nil {
		sv = &ListIdentitiesOutput{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("Identities", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentListOfIdentities(&sv.Identities, nodeDecoder); err != nil {
					return err
				}
			
			case strings.EqualFold("NextToken", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					sv.NextToken = ptr.String(xtv)
				}
			
			case strings.EqualFold("ResponseMetadata", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentResponseMetadata(&sv.ResponseMetadata, nodeDecoder); err != nil {
					return err
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentSendEmailOutput(v **SendEmailOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *SendEmailOutput
	if *v == nil {
		sv = &SendEmailOutput{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("MessageId", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					sv.MessageId = ptr.String(xtv)
				}
			
			case strings.EqualFold("ResponseMetadata", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentResponseMetadata(&sv.ResponseMetadata, nodeDecoder); err != nil {
					return err
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentSendRawEmailOutput(v **SendRawEmailOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *SendRawEmailOutput
	if *v == nil {
		sv = &SendRawEmailOutput{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("MessageId", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					sv.MessageId = ptr.String(xtv)
				}
			
			case strings.EqualFold("ResponseMetadata", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentResponseMetadata(&sv.ResponseMetadata, nodeDecoder); err != nil {
					return err
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentVerifyDomainDkimOutput(v **VerifyDomainDkimOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *VerifyDomainDkimOutput
	if *v == nil {
		sv = &VerifyDomainDkimOutput{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("DkimTokens", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentListOfDkimTokens(&sv.DkimTokens, nodeDecoder); err != nil {
					return err
				}
			
			case strings.EqualFold("ResponseMetadata", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentResponseMetadata(&sv.ResponseMetadata, nodeDecoder); err != nil {
					return err
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentVerifyDomainIdentityOutput(v **VerifyDomainIdentityOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *VerifyDomainIdentityOutput
	if *v == nil {
		sv = &VerifyDomainIdentityOutput{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("ResponseMetadata", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentResponseMetadata(&sv.ResponseMetadata, nodeDecoder); err != nil {
					return err
				}
			
			case strings.EqualFold("VerificationToken", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					sv.VerificationToken = ptr.String(xtv)
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}

func awsAwsquery_deserializeOpDocumentVerifyEmailIdentityOutput(v **VerifyEmailIdentityOutput, decoder smithyxml.NodeDecoder) error {
	if v == nil {
		return fmt.Errorf("unexpected nil of type %T", v)
	}
	var sv *VerifyEmailIdentityOutput
	if *v == nil {
		sv = &VerifyEmailIdentityOutput{}
		} else {
			sv = *v
		}
	
	for {
		t, done, err := decoder.Token()
		if err != nil { return err }
		if done { break }
		originalDecoder := decoder
		decoder = smithyxml.WrapNodeDecoder(originalDecoder.Decoder, t)
		switch {
			case strings.EqualFold("ResponseMetadata", t.Name.Local):
				nodeDecoder := smithyxml.WrapNodeDecoder(decoder.Decoder, t)
				if err := awsAwsquery_deserializeDocumentResponseMetadata(&sv.ResponseMetadata, nodeDecoder); err != nil {
					return err
				}
			
			case strings.EqualFold("VerifyEmailIdentityResult", t.Name.Local):
				val, err := decoder.Value()
				if err != nil { return err }
				if val == nil { break }
				{
					xtv := string(val)
					sv.VerifyEmailIdentityResult = ptr.String(xtv)
				}
			
			default:
				// Do nothing and ignore the unexpected tag element
				err = decoder.Decoder.Skip()
				if err != nil { return err }
			
		}
		decoder = originalDecoder
	}
	*v = sv
	return nil
}
